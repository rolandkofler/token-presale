var sikobaPresaleSource = "pragma solidity ^0.4.8;contract Owned { address public owner; function Owned() { owner = msg.sender; } modifier onlyOwner() { if (msg.sender != owner) { throw; } _; }}contract SikobaPresale is Owned { uint256 public totalFunding; uint256 public constant MINIMUM_PARTICIPATION_AMOUNT = 10 ether; uint256 public constant MAXIMUM_PARTICIPATION_AMOUNT = 1000 ether; uint256 public constant PRESALE_MINIMUM_FUNDING = 1500 ether; uint256 public constant PRESALE_MAXIMUM_FUNDING = 2000 ether; uint256 public constant TOTAL_PREALLOCATION = 1400 ether; uint256 public constant PRESALE_START_DATE = 1489928842; uint256 public constant PRESALE_END_DATE = 1489929142; uint256 public constant OWNER_CLAWBACK_DATE = 1489929382; mapping (address => uint256) public balanceOf; event LogParticipation(address indexed sender, uint256 value, uint256 timestamp); function SikobaPresale () payable { assertEquals(TOTAL_PREALLOCATION, msg.value); addBalance(0x0020017ba4c67f76c76b1af8c41821ee54f37171, 1000 ether); addBalance(0x0036f6addb6d64684390f55a92f0f4988266901b, 400 ether); assertEquals(TOTAL_PREALLOCATION, totalFunding); } function () payable { if (now < PRESALE_START_DATE) throw; if (now > PRESALE_END_DATE) throw; if (msg.value < MINIMUM_PARTICIPATION_AMOUNT) throw; if (msg.value > MAXIMUM_PARTICIPATION_AMOUNT) throw; if (safeIncrement(totalFunding, msg.value) > PRESALE_MAXIMUM_FUNDING) throw; addBalance(msg.sender, msg.value); } function ownerWithdraw(uint256 value) external onlyOwner { if (now <= PRESALE_END_DATE) throw; if (totalFunding < PRESALE_MINIMUM_FUNDING) throw; if (!owner.send(value)) throw; } function participantWithdrawIfMinimumFundingNotReached(uint256 value) external { if (now <= PRESALE_END_DATE) throw; if (totalFunding >= PRESALE_MINIMUM_FUNDING) throw; if (balanceOf[msg.sender] < value) throw; balanceOf[msg.sender] = safeDecrement(balanceOf[msg.sender], value); if (!msg.sender.send(value)) throw; } function ownerClawback() external onlyOwner { if (now < OWNER_CLAWBACK_DATE) throw; if (!owner.send(this.balance)) throw; } function addBalance(address participant, uint256 value) private { balanceOf[participant] = safeIncrement(balanceOf[participant], value); totalFunding = safeIncrement(totalFunding, value); LogParticipation(participant, value, now); } function assertEquals(uint256 expectedValue, uint256 actualValue) private constant { if (expectedValue != actualValue) throw; } function safeIncrement(uint256 base, uint256 increment) private constant returns (uint256) { uint256 result = base + increment; if (result < base) throw; return result; } function safeDecrement(uint256 base, uint256 increment) private constant returns (uint256) { uint256 result = base - increment; if (result > base) throw; return result; }}"